# 01.01 判定字符是否唯一 (2021.03.12)

https://leetcode-cn.com/problems/is-unique-lcci/

## Solution 1: Brute-force

- $TC:O(n^2)$
- $SC:O(1)$

```java
class Solution {
    public boolean isUnique(String astr) {
        if (astr == null || astr.length() == 0) return true;
        
        for (int i = 0; i < astr.length(); i++) {
            for (int j = i + 1; j < astr.length(); j++) {
                if (astr.charAt(i) == astr.charAt(j)) return false;
            }
        }
        
        return true;
    }
}
```

## Solution 2: HashSet

- $TC:O(n)$
- $SC:O(n)$

```java
class Solution {
    public boolean isUnique(String astr) {
        Set<Character> set = new HashSet<>();
        for (char c : astr.toCharArray()) {
            if (set.contains(c)) return false;
            set.add(c);
        }
        return true;
    }
}
```

## Solution 3: Bit manipulation

- $TC:O(n)$
- $SC:O(1)$
- 基于astr只包含26个小写英文字母的前提下实现，如果包含更多的字符，则需要相应位数的bitmask。
- 当对应的位数太大的时候（比如包含所有Unicode字符），那么使用HashSet是比较好的选择。

```java
class Solution {
    public boolean isUnique(String astr) {
        int bitmask = 0;
        for (int i = 0; i < astr.length(); i++) {
            char c = astr.charAt(i);
            int offset = c - 'a';
            if ((bitmask & (1 << offset)) > 0) return false;
            bitmask |= (1 << offset);
        }
        return true;
    }
}
```