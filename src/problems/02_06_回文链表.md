# 02.06. 回文链表 (2021.06.10)

https://leetcode-cn.com/problems/palindrome-linked-list-lcci/

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
```

## Solution 1: 2 pointers

- $TC:O(n)$
- $SC:O(1)$
- 先通过快慢指针找到链表的中间结点，然后从slow开始翻转后半部分链表，最后同时从head和tail开始遍历并比较两段链表。
- 如果想要还原，那么就在从后往前遍历后半部分链表的同时，再次进行翻转。

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode slow = head, fast = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }

        ListNode prev = null;
        while (slow != null) {
            ListNode next = slow.next;
            slow.next = prev;
            prev = slow;
            slow = next;
        }

        ListNode p = head, q = prev;
        while (p != null && q != null) {
            if (p.val != q.val) return false;
            p = p.next;
            q = q.next;
        }
        return true;
    }
}
```

## Solution 2: Turn to Array

- $TC:O(n)$
- $SC:O(n)$

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        List<Integer> elems = new ArrayList<>();
        ListNode p = head;
        while (p != null) {
            elems.add(p.val);
            p = p.next;
        }

        int i = 0, j = elems.size() - 1;
        while (i < j) {
            if (!elems.get(i++).equals(elems.get(j--))) return false;
        }
        return true;
    }
}
```